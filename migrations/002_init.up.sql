CREATE TABLE sessions (
  session_id char(128) PRIMARY KEY,
  user_id BIGINT,
  questions JSONB,
  user_answers INT[],
  expired_at TIMESTAMP
);

CREATE TABLE questions (
  question_id SERIAL PRIMARY KEY,
  question_text TEXT NOT NULL,
  question_options JSONB NOT NULL,
  answer INT NOT NULL,
  explanation TEXT,
  grade TEXT NOT NULL
);

INSERT INTO questions (question_text, question_options, answer, explanation, grade)
VALUES
('Что такое горутина (goroutine) в Go?', '["Класс объектов", "Поток выполнения", "Интерфейс", "Группа функций"]', 1, 'Это легковесные потоки, которые реализуют конкурентное программирование. Они управляются рантаймом, а не операционной системой', 'junior'),
('Каким образом проверить ошибку в Go?', '["if err != nil { }", "err := checkError()", "if error { }", "if err == nil { }"]', 0, 'Нужно сначала вернуть из функции переменную err, а потом проверить ее на nil', 'junior'),
('Что такое defer в Go?', '["Запись данных", "Выполнение после возврата", "Оператор итерации", "Отложенное выполнение"]', 3, 'Ключевое слово defer используется для отложенного выполнения функции/метода до тех пор, пока текущая функция не завершится', 'junior'),
('Каким образом происходит передача параметров в функции в Go?', '["По значению (pass by value)", "По ссылке (pass by reference)", "По указателю", "По имени параметра"]', 0, 'Всякий раз, когда мы передаем аргумент в функцию, функция получает копию первоначального значения', 'junior'),
('Что такое слайс (slice) в Go?', '["Указатель на массив", "Динамический массив", "Класс для работы с файлами", "Массив фиксированного размера"]', 1, 'Это массив неопределённой длины', 'junior'),
('Что такое интерфейс в Go?', '["Набор методов", "Имя типа данных", "Указатель на функцию", "Описание структуры"]', 0, 'Набор методов', 'junior'),
('Каким образом происходит обработка ошибок в Go?', '["Исключения", "Возврат ошибки в функции", "Ловушка для ошибок", "Паника"]', 1, 'Ошибки - значения, возвращаемые функциями', 'junior'),
('Что такое метод в Go?', '["Функция, связанная с определенным типом", "Глобальная функция", "Макрос", "Синтаксическая конструкция"]', 1, 'В Go нет классов, но существуют структуры с методами. Метод — это функция с дополнительным аргументом, который указывается в скобках между func и названием функции', 'junior'),
('Go - императивный или декларативный?', '["не знаю", "декларативный", "императивный и декларативный", "императивный"]', 3, 'Императивное программирование — это описание того, как ты делаешь что-то (т.е. конкретно описываем необходимые действия для достижения определенного результата), а декларативное — то, что ты делаешь', 'junior'),
('Что представляют из себя строки в go?', '["не знаю", "массив байт", "тип данных, предназначенный для работы с текстом", "любые текстовые данные"]', 1, 'это последовательность байт', 'junior'),
('Что получится, если разделить int на 0, float на 0?', '["паника в обоих случаях", "невозможно в обоих случаях", "ошибка/бесконечность", "ноль/ноль"]', 2, 'Деление int на 0 в go невозможно и вызовет ошибку компилятора, а деление float на 0 дает в своем результате бесконечность.', 'junior'),
('Как создать новую горутину в Go?', '["go func()", "new goroutine", "goroutine func()", "start go func"]', 0, 'Для создания новой горутины в Go используется ключевое слово go перед вызовом функции.', 'junior'),
('Как проверить длину слайса в Go?', '["size(slice)", "length(slice)", "len(slice)", "count(slice)"]', 2, 'Для проверки длины слайса в Go используется функция len().', 'junior'),
('Как объявить структуру в Go?', '["struct Struct {}", "type Struct struct {}", "struct {} Struct", "define Struct {}"]', 1, 'В Go структуры объявляются с использованием ключевых слов type и struct.', 'junior'),
('Как создать канал в Go?', '["create(chan int)", "make(chan int)", "new(chan int)", "chan int{}"]', 1, 'Для создания канала в Go используется функция make().', 'junior'),
('Что делает оператор select в Go?', '["Выбирает случайный канал", "Параллельно выполняет функции", "Синхронизирует выполнение горутин", "Выполняет операции с несколькими каналами"]', 3, 'select позволяет go-процедуре находиться в ожидании нескольких операций передачи данных. select блокируется до тех пор, пока один из его блоков case не будет готов к запуску, а затем выполняет этот блок. Если сразу несколько блоков могут быть запущены, то выбирается рандомный', 'junior'),
('Как инициализировать слайс с длиной 5 в Go?', '["make([]int, 5)", "create([]int, 5)", "new([]int, 5)", "[]int{5}"]', 0, 'Для инициализации слайса с длиной 5 в Go используется функция make([]int, 5).', 'junior'),
('Что возвращает функция recover() в Go?', '["Ошибку", "Паническое значение", "Значение nil", "Статус выполнения"]', 1, 'Функция recover() в Go возвращает паническое значение, если она вызывается в отложенной функции после panic().', 'junior'),
('Как в Go избежать состояния гонки?', '["Использовать мьютексы", "Использовать каналы", "Использовать атомарные операции", "Все вышеперечисленное"]', 3, 'В Go можно избежать состояния гонки, используя мьютексы, каналы и атомарные операции.', 'junior'),
('Что делает функция runtime.Gosched() в Go?', '["Завершает текущую горутину", "Усыпляет текущую горутину", "Передает управление другой горутине", "Останавливает все горутины"]', 2, 'Функция runtime.Gosched() передает управление другой горутине, позволяя планировщику выполнить другие задачи.', 'junior'),
('Как в Go реализуется наследование?', '["Использование интерфейсов", "Встраивание структур", "Наследование классов", "Все вышеперечисленное"]', 1, 'В Go наследование реализуется через встраивание структур.', 'junior'),
('Какую роль играет интерфейс в Go?', '["Определяет методы, которые должен реализовать тип", "Объявляет поля структуры", "Определяет пакет", "Объявляет переменную"]', 0, 'Интерфейс в Go определяет методы, которые должен реализовать тип.', 'junior'),
('Как в Go реализовать чистую архитектуру?', '["Разделение логики на слои", "Использование интерфейсов для взаимодействия между слоями", "Использование зависимостей, инъекций и тестов", "Все вышеперечисленное"]', 3, 'В Go чистая архитектура реализуется через разделение логики на слои, использование интерфейсов и зависимостей, инъекций и тестов.', 'junior'),
('Как вызвать метод, привязанный к структуре, в Go?', '["instance.method()", "method(instance)", "instance->method()", "instance:method()"]', 0, 'Метод, привязанный к структуре, вызывается с использованием синтаксиса instance.method().', 'junior'),
('Что такое пустой интерфейс interface{} в Go?', '["Интерфейс без методов", "Интерфейс с одним методом", "Интерфейс для работы с каналами", "Интерфейс для работы с файлами"]', 0, 'Пустой интерфейс interface{} не содержит методов и может быть использован для хранения значения любого типа.', 'junior'),
('Как объявить метод с указателем на структуру в качестве получателя в Go?', '["func (s StructType) MethodName()", "func (s *StructType) MethodName()", "func MethodName(s StructType)", "func MethodName(s *StructType)"]', 1, 'Метод с указателем на структуру в качестве получателя объявляется с использованием синтаксиса func (s *StructType) MethodName().', 'junior'),
('Как объявить анонимную функцию в Go?', '["func() {}", "() => {}", "function() {}", "func {}"]', 0, 'Анонимная функция объявляется с использованием синтаксиса func() {}.', 'junior'),
('Как определить метод, который может принимать параметры любого типа в Go?', '["func MethodName[T any](param T)", "func MethodName(param interface{})", "func MethodName(param ...interface{})", "func MethodName(param T)"]', 2, 'Метод, который может принимать параметры любого типа, определяется с использованием синтаксиса func MethodName(param ...interface{}).', 'junior'),
('Как в Go реализовать обобщенные типы?', '["Использовать интерфейсы", "Использовать пустые интерфейсы", "Использовать параметры типов", "Go не поддерживает обобщенные типы"]', 3, 'На данный момент Go не поддерживает обобщенные типы напрямую.', 'junior'),
('Как определить deadlock в Go программе?', '["Программа завершает работу с ошибкой", "Все горутины заблокированы", "Программа зависает", "Все вышеперечисленное"]', 3, 'Deadlock в Go программе проявляется, когда все горутины заблокированы и программа зависает или завершает работу с ошибкой.', 'junior'),
('Какое значение принимает неинициализированная переменная int в Go?', '["nil", "1", "0", "-1"]', 2, 'Неинициализированная переменная int принимает значение 0 в Go.', 'junior'),
('Какой метод используется для преобразования строки в число с плавающей точкой?', '["strconv.Atoi()", "strconv.ParseFloat()", "strconv.ParseInt()", "strconv.FormatFloat()"]', 1, 'Метод strconv.ParseFloat() используется для преобразования строки в число с плавающей точкой.', 'junior'),
('Что делает ключевое слово fallthrough в конструкции switch?', '["Завершает выполнение switch", "Продолжает выполнение следующего case", "Вызывает панику", "Пропускает текущий case"]', 1, 'Ключевое слово fallthrough продолжает выполнение следующего case в конструкции switch.', 'junior'),
('Как объявить метод, который принимает переменное количество аргументов одного типа?', '["func MethodName(args ...Type)", "func MethodName(args []Type)", "func MethodName(args ...interface{})", "func MethodName(args ...T)"]', 0, 'Метод, который принимает переменное количество аргументов одного типа, объявляется с использованием синтаксиса func MethodName(args ...Type).', 'junior'),
('Какое значение можно использовать в конструкции select для выполнения по умолчанию?', '["default:", "else:", "case nil:", "switch:"]', 0, 'Значение default: используется в конструкции select для выполнения по умолчанию, если ни один из case не готов к выполнению.', 'junior'),
('Как объявить метод, который будет доступен только внутри пакета?', '["func methodName() {}", "func MethodName() {}", "private func methodName() {}", "internal func methodName() {}"]', 0, 'Метод, который начинается с маленькой буквы, будет доступен только внутри пакета.', 'junior'),
('Что делает функция copy() в Go?', '["Копирует данные из строки в строку", "Копирует данные из карты в карту", "Копирует данные из структуры в структуру", "Копирует данные из одного среза в другой"]', 3, 'Функция copy() копирует данные из одного среза в другой.', 'junior'),
('Что произойдет, если два разных пакета импортируют друг друга?', '["Будет ошибка компиляции", "Программа зависнет", "Будет ошибка времени выполнения", "Программа выполнится без ошибок"]', 0, 'Если два разных пакета импортируют друг друга, будет ошибка компиляции из-за циклической зависимости.', 'junior'),
('Как объявить канал, который может только отправлять данные?', '["chan int", "<-chan int", "chan<- int", "chan<- int, <-chan int"]', 2, 'Канал, который может только отправлять данные, объявляется как chan<- int.', 'junior'),
('Какой метод используется для настройки параллелизма выполнения тестов?', '["t.concurrent()", "t.RunParallel()", "t.Run()", "t.Concurrent()"]', 2, 'Метод t.Parallel() используется для настройки параллелизма выполнения тестов.', 'junior'),
('Какой метод из пакета context используется для создания дочернего контекста с тайм-аутом?', '["WithCancel", "WithDeadline", "WithTimeout", "WithValue"]', 2, 'Метод context.WithTimeout используется для создания дочернего контекста с тайм-аутом.', 'junior'),
('Чем отличается интерфейс от структуры в Go?', '["Интерфейс не содержит методов", "Структура используется только для хранения данных", "Интерфейс определяет только поведение, а структура - данные и поведение", "Структура определяет только поведение"]', 2, 'Интерфейс в Go определяет только поведение, а структура может содержать и данные, и поведение.', 'junior'),
('Что такое пакетный рантайм (package runtime) в Go?', '["Встроенные функции для работы с пакетами", "Часть стандартной библиотеки, обеспечивающая основные функции исполнения программы", "Интерфейсы для работы с горутинами", "Расширения стандартной библиотеки"]', 1, 'Пакетный рантайм в Go - это часть стандартной библиотеки, которая обеспечивает основные функции исполнения программы, включая управление памятью и горутинами.', 'junior'),
('Из чего состоит файл go.mod?', '["Список всех используемых пакетов", "Информация о версии Go", "Метаданные проекта и его зависимости", "Исполняемый файл проекта"]', 2, 'Файл go.mod состоит из метаданных проекта и его зависимостей, включая список используемых пакетов и их версии.', 'junior'),
('Для чего нужен replace в go.mod?', '["Для временного отключения зависимостей", "Для замены стандартных пакетов на пользовательские реализации", "Для перехода на другую версию Go", "Для обновления всех зависимостей"]', 1, 'Ключевое слово replace в go.mod используется для замены стандартных пакетов на пользовательские реализации в процессе разработки или тестирования.', 'junior'),
('Что означает indirect в go.mod?', '["Зависимость не явно задана в проекте", "Зависимость косвенно используется в проекте", "Зависимость не должна обновляться автоматически", "Зависимость используется только для разработки"]', 1, 'Когда зависимость помечена как indirect в go.mod, это означает, что она косвенно используется в проекте через другие зависимости.', 'junior'),
('Что включает в себя структура слайса?', '["len, cap", "len и cap", "Ссылку на базовый массив, len и cap", "Слайс это не структура"]', 2, 'Слайс - структура go, которая содержит в себе ссылку на базовый массив, длину (len) и ёмкость (cap).', 'junior'),
('Что такое Big O-нотация?
```
  1. Оценка объема памяти, используемого алгоритмом
  2. Оценка времени работы алгоритма в среднем случае
  3. Оценка времени работы алгоритма в худшем случае
  4. Все вышеперечисленное
```', '["1", "2", "3", "4"]', 2, 'Big O-нотация используется для оценки временной сложности алгоритма в худшем случае.', 'junior'),
('Может ли стек горутины быть бесконечным?', '["Да, может быть", "Нет, размер стека ограничен доступной физической памятью", "Да, если горутина использует мало памяти", "Нет, стек горутины имеет фиксированный размер"]', 1, 'Стек горутины зависит от архитектуры и составляет 1ГБ для 64-разрядных систем и 250МБ для 32-разрядных систем.', 'junior'),
('Чему равны zero-value для слайса?', '["error,", "0, 0", "false", "nil, nil"]', 1, 'Zero-value для слайса - nil, а его длина и ёмкость (len, cap) равны нулю, т.к. "под ним" нет инициализированного масива', 'junior'),
('Как проверить слайс var a []int на пустоту?', '["fmt.Println(a == nil)", "fmt.Println(!a)", "Стандартная библиотека не даёт проверки слайса на пустоту","fmt.Println(len(a) == 0)"]', 3, 'Самый надежный способ проверить слайс на пустоту - это проверить его длину на ноль.', 'junior'),

('Каким образом проверить ошибку в Go?', '["if err != nil { }", "err := checkError()", "if error { }", "if err == nil { }"]', 0, 'Нужно сначала вернуть из функции переменную err, а потом проверить ее на nil', 'junior'),
('Что такое goroutine leak?', '["Потеря горутин", "Завершение горутин", "Утечка горутин", "Ошибка в горутине"]', 2, 'Goroutine leak — это утечка горутин, которая продолжает работать, когда она уже не нужна.', 'middle'),
('Какой из подходов лучше всего использовать для параллельной обработки данных в Go?', '["Структуры и интерфейсы", "Мьютексы и условные переменные", "Стандартные функции и методы", "Горутины и каналы"]', 3, 'В Go для параллельной обработки данных лучше всего использовать горутины и каналы.', 'middle'),
('Что такое race condition и как его избежать в Go?', '["Конкуренция за ресурсы между горутинами", "Проблемы с памятью", "Неправильное использование функций", "Ошибки при работе с интерфейсами"]', 0, 'Race condition — это конкуренция за ресурсы между горутинами. Его можно избежать, используя мьютексы, каналы и атомарные операции.', 'middle'),
('Как использовать пакет sync в Go для синхронизации горутин?', '["sync.Mutex", "sync.WaitGroup", "sync.Cond", "Все вышеперечисленное"]', 3, 'Пакет sync в Go предоставляет такие примитивы синхронизации, как sync.Mutex, sync.WaitGroup и sync.Cond.', 'middle'),
('Как реализовать шаблон проектирования "Фабрика" в Go?', '["Использовать функции-конструкторы", "Использовать методы структур", "Использовать интерфейсы", "Использовать пакеты"]', 0, 'В Go шаблон проектирования "Фабрика" можно реализовать с помощью функций-конструкторов.', 'middle'),
('Как в Go работает garbage collection?', '["Оптимизирует работу программы", "Управляет выделением и освобождением памяти вручную", "Освобождает память, занимаемую ненужными объектами", "Автоматически исправляет ошибки"]', 2, 'Garbage collection в Go автоматически освобождает память, занимаемую ненужными объектами.', 'middle'),
('Что такое pattern matching (сопоставление значения с шаблоном) в Go?', '["Сопоставление с шаблоном", "Ответы a, c", "Использование регулярных выражений", "Go не поддерживает pattern matching"]', 3, 'Go не поддерживает pattern matching, который присутствует в других языках, таких как Haskell или Erlang.', 'middle'),
('Какой из методов соответствует интерфейсу io.Reader в Go?', '["Write(p []byte) (n int, err error)", "Read(p []byte) (n int, err error)", "Close() error", "Open(name string) (file *File, err error)"]', 1, 'Метод Read(p []byte) (n int, err error) соответствует интерфейсу io.Reader, который позволяет считывать данные из источника в буфер p.', 'middle'),
('Что произойдет, если вызвать метод на nil указателе в Go?', '["Программа завершится с паникой", "Метод будет вызван без ошибок", "Вернется nil", "Будет вызван метод nil объекта"]', 0, 'Если вызвать метод на nil указателе, программа завершится с паникой, если метод не обрабатывает nil указатели явно.', 'middle'),
('Какой метод из пакета sync.WaitGroup уменьшает счетчик горутин на единицу?', '["Done()", "Add()", "Wait()", "Subtract()"]', 0, 'Метод Done() уменьшает счетчик горутин на единицу в пакете sync.WaitGroup.', 'middle'),
('Что произойдет, если закрыть канал, и потом попытаться отправить в него значение?', '["Будет отправлено значение", "Программа завершится с паникой", "Ничего не произойдет", "Будет создан новый канал"]', 1, 'Если закрыть канал и потом попытаться отправить в него значение, программа завершится с паникой.', 'middle'),
('Что произойдет, если не вызвать метод Done() на WaitGroup в Go?', '["Программа завершится с ошибкой", "Программа будет ждать бесконечно", "Ничего не произойдет", "Будет вызвана паника"]', 1, 'Если не вызвать метод Done() на WaitGroup, программа будет ждать бесконечно, так как WaitGroup никогда не достигнет нуля.', 'middle'),
('Что произойдет, если вызвать panic внутри defer функции?', '["Ничего не произойдет", "Программа продолжит выполнение", "Другая defer функция будет вызвана", "Программа завершится с паникой"]', 3, 'Если вызвать panic внутри defer функции, программа завершится с паникой после выполнения всех остальных отложенных функций.', 'middle'),
('Как определить метод, который принимает и возвращает каналы?', '["func MethodName(chan int) chan int", "func MethodName(chan<- int) <-chan int", "func MethodName(chan int) (chan int)", "Все вышеперечисленное"]', 3, 'Все вышеперечисленные способы определяют метод, который принимает и возвращает каналы.', 'middle'),
('Что произойдет, если вызвать метод на nil интерфейсе в Go?', '["Программа завершится с паникой", "Метод будет вызван без ошибок", "Вернется nil", "Будет вызван метод nil объекта"]', 1, 'Если вызвать метод на nil интерфейсе, программа завершится с паникой, если метод не обрабатывает nil явно.', 'middle'),
('Какой тип блокировки обеспечивает одновременное чтение, но эксклюзивное написание?', '["Mutex", "RWMutex", "Once", "WaitGroup"]', 1, 'RWMutex (Read-Write Mutex) обеспечивает одновременное чтение, но эксклюзивное написание.', 'middle'),
('Что произойдет, если не закрыть канал, который больше не используется?', '["Программа завершится с ошибкой", "Произойдет утечка памяти", "Горутины, ожидающие на этом канале, заблокируются", "Ничего не произойдет"]', 2, 'Если не закрыть канал, горутины, ожидающие на этом канале, заблокируются.', 'middle'),
('Что произойдет, если вызывать метод Lock() на уже заблокированном мьютексе?', '["Программа завершится с ошибкой", "Произойдет дедлок", "Горутина продолжит выполнение", "Мьютекс автоматически разблокируется"]', 1, 'Если вызвать метод Lock() на уже заблокированном мьютексе, произойдет дедлок, т.к. горутина будет ждать освобождения мьютекса.', 'middle'),
('Какой тип блокировки обеспечивает однократное выполнение определенного кода?', '["Mutex", "RWMutex", "Once", "WaitGroup"]', 2, 'Once обеспечивает однократное выполнение определенного кода.', 'middle'),
('Как избежать утечек памяти при использовании таймеров в Go?', '["Использовать defer для остановки таймера", "Использовать таймеры с канала", "Обнулять таймер", "Использовать context для отмены"]', 0, 'Использование defer для остановки таймера помогает избежать утечек памяти.', 'middle'),
('Что произойдет, если вызвать метод RLock() на RWMutex в Go, когда другой горутин вызвал Lock()?', '["Произойдет дедлок", "Метод RLock() будет блокироваться до освобождения Lock()", "Будет вызвана паника", "Горутина продолжит выполнение"]', 1, 'Метод RLock() будет блокироваться до тех пор, пока Lock() не будет освобожден.', 'middle'),
('Какой метод используется для завершения работы горутины при закрытии программы?', '["runtime.Goexit()", "runtime.Gosched()", "runtime.GC()", "runtime.NumGoroutine()"]', 0, 'Метод runtime.Goexit() используется для завершения работы текущей горутины.', 'middle'),
('Какой метод из пакета sync используется для безопасного доступа к целочисленным значениям из нескольких горутин?', '["sync.RWMutex.RLock()", "sync.Mutex.Lock()", "sync.WaitGroup.Wait()", "sync/atomic.AddInt32()"]', 3, 'Метод sync/atomic.AddInt32() используется для безопасного доступа и изменения целочисленных значений из нескольких горутин.', 'middle'),
('Какой алгоритм сортировки имеет наилучшую временную сложность в среднем случае среди сравнительных алгоритмов?', '["Пузырьковая сортировка (Bubble Sort)", "Сортировка слиянием (Merge Sort)", "Быстрая сортировка (Quick Sort)", "Вставочная сортировка (Insertion Sort)"]', 2, 'Быстрая сортировка (Quick Sort) имеет наилучшую временную сложность O(n log n) в среднем случае среди сравнительных алгоритмов сортировки.', 'middle'),
('Что такое gRPC в контексте сетевого взаимодействия в Go?', '["Протокол для передачи SOAP-сообщений", "Формат передачи данных через RESTful API", "Протокол для удаленного вызова процедур (RPC) с использованием HTTP/2", "Фреймворк для разработки веб-приложений"]', 3, 'gRPC - это протокол для удаленного вызова процедур (RPC) с использованием HTTP/2, предназначенный для эффективного взаимодействия между различными сервисами.', 'middle'),
('Какие преимущества предоставляет gRPC по сравнению с RESTful API?', '["Более высокая производительность и эффективность благодаря использованию HTTP/2 и сериализации Protocol Buffers", "Простота использования и понимания", "Легкость в развертывании", "Все вышеперечисленное"]', 0, 'gRPC предлагает более высокую производительность и эффективность благодаря использованию HTTP/2 и сериализации Protocol Buffers.', 'middle'),
('Какое преимущество предоставляет использование Protocol Buffers в gRPC?', '["Простота в использовании", "Высокая производительность при передаче данных", "Легкость в развертывании", "Возможность работы с JSON-форматом"]', 1, 'Protocol Buffers предоставляют высокую производительность при передаче данных благодаря компактному бинарному формату.', 'middle'),
('Какой тип данных в Go часто используется для представления JSON-структур в RESTful API?', '["Структуры", "Массивы", "Карты", "Целые числа"]', 0, 'В Go для представления JSON-структур в RESTful API часто используются структуры данных.', 'middle'),
('Чем pointer receiver отличается от value receiver?
```
  1. Pointer receiver принимает копию значения, а value receiver принимает указатель на значение.
  2. Изменения, внесенные в указатель на значение в методе с pointer receiver, не отражаются на исходном значении.
  3. Pointer receiver используется, когда не требуется изменять исходное значение, в то время как value receiver используется, когда требуется изменять исходное значение.
  4. Pointer receiver принимает указатель на значение, а value receiver принимает копию значения.
```', '["1", "2", "3", "4"]', 3, 'pointer receiver в Go принимает указатель на значение, что позволяет методу изменять исходное значение. Изменения, внесенные в указатель на значение в методе с pointer receiver, отражаются на исходном значении за пределами метода. 
value receiver принимает копию значения, делая его неспособным изменять исходное значение. Изменения, внесенные в копию значения в методе с value receiver, остаются локальными для метода и не влияют на исходное значение. ', 'middle'),
('Чем буферизованный канал отличается от небуферизованного канала?
```
  1. Буферизованный канал позволяет отправителю отправлять данные без блокировки, если буфер не заполнен, в то время как небуферизованный канал блокирует отправителя до тех пор, пока данные не будут прочитаны.
  2. В буферизованном канале отправитель может отправлять данные, даже если нет читателя, до тех пор, пока буфер не заполнится, а в небуферизованном канале отправитель должен ждать, пока данные не будут прочитаны.
  3. Буферизованный канал имеет фиксированный размер буфера, который определяется при создании канала, в то время как небуферизованный канал не имеет буфера и передача данных происходит синхронно.
  4. Основное отличие - буферизованный канал позволяет отправителю отправлять данные асинхронно, в то время как небуферизованный канал требует синхронной передачи данных.
```', '["1", "2", "3", "4"]', 0, 'В буферизованном канале отправитель может отправлять данные без блокировки, если буфер не заполнен, что позволяет продолжать выполнение программы, даже если читатель не готов принять данные. В то время как в небуферизованном канале отправитель будет заблокирован до тех пор, пока данные не будут прочитаны из канала. Таким образом, основное отличие заключается в возможности асинхронной передачи данных в буферизованном канале.', 'middle'),

('Что выведет код?
```
package main

func main(){
  for counter, i := 0, 0; i < 9; i++ {
    defer func() {
      if counter%2 == 1 {
        print(counter)
      }
      counter++
    }()
  }
}
```', '["Ничего", "1357", "Зависит от версии языка", "Ошибка компиляции"]', 2, 'В версии 1.22 изменилась семантика for, поэтому вывод будет зависеть от версии', 'junior'),
('Что выведет код?
```
package main

import "fmt"

func main(){
  var a uint8 = 10
  var b uint8 = 30
  var c uint8 = a * b
  fmt.Println(c)
}
```', '["300", "44", "Ошибку компиляции", "344"]', 1, 'Максимальное значение uint8 - 255, поэтому результат обернётся вокруг этого максимального значения и будет равен 300-256=44
[playgroung](https://goplay.space/#ZXCOdU5Tql0)', 'junior'),
('Что выведет код?
```
package main

func main() {
	v := 5
	p := &v
	println(*p)

	changePointer(p)
	println(*p)
}

func changePointer(p *int) {
	v := 3
	p = &v
}

```', '["5, 5", "5", "Ошибку компиляции", "panic"]', 0, 'В функции changePointer мы изменяем сам указатель p, но не изменяем значение, на которое он указывает. Когда мы передаем указатель p в функцию changePointer, создается копия указателя p, которая указывает на значение 3. Но, после завершения функции changePointer, эта копия уничтожается, и исходный указатель p в функции main остается указывать на значение 5.
[playgroung](https://goplay.space/#E3C3hi4asTQ)', 'middle'),

('Какое будет значение у переменной x после выполнения программ?
```
package main

func square(x *float64) {
	*x = *x * *x
}

func main() {
	x := 1.5
	square(&x)

	fmt.Println(x)
}

```', '["1.25", "2.25", "2.5", "1"]', 1, 'Это происходит потому, что в функции square мы передаем указатель на переменную x, а не саму переменную. В функции square происходит умножение значения, на которое указывает указатель x, на само это значение. Таким образом, значение переменной x изменяется на результат умножения 1.5 на 1.5, что равно 2.25.
[playgroung](https://goplay.space/#J-R1I5Ih8Jt)', 'middle'),

('Что выведет программа и почему?
```
package main

import "fmt"

type Person struct {
  Name string
}

func changeName(person *Person) {
  person = &Person {
    Name: "Alice",
  }
}

func main() {
  person := &Person {
    Name: "Bob",
  }
  fmt.Println(person.Name)
  changeName(person)
  fmt.Println(person.Name)
}
```', '["Alice\nBob", "Bob\nBob", "Alice\nAlice", "Bob"]', 1, 'Выведет Bob\nBob, потому что в функции changeName мы передаем указатель на переменную person, а не саму переменную. В функции changeName мы передаем в функцию значение переменной person, которое равно &Person{Name: "Bob"}. При вызове функции changeName переменная person становится равной &Person{Name: "Alice"}, которое в свою очередь становится равным &Person{Name: "Bob"}.
[playgroung](https://goplay.space/#wZobTUnG9jg)', 'middle'),

('Что выведет программа?
```
package main

import "fmt"

type Count int

func (c Count) Increment() {
	c++
}

func main() {
	var count Count
	count.Increment()
	fmt.Print(count)
}

```', '["2", "1", "0", "error"]', 2, 'При вызове метода Increment() на переменной count, значение "c" увеличивается на 1, но это изменение происходит на копии "c", а не на самой переменной count. Поскольку в методе Increment() используется значение-получатель (value receiver), изменения не отражаются на исходной переменной count.
Поэтому после вызова count.Increment(), значение count остается равным нулю, и при выводе fmt.Print(count) будет выведено "0".
[playgroung](https://goplay.space/#NeDKMbWAWkD)', 'middle'),

('Что выведет программа?
```
package main

import "fmt"

func main() {
	s0 := "some string"
	s1 := []byte(s0)

	s2 := s1[5:]

	s2[3] = "o"

	fmt.Println(string(s2))
	fmt.Println(string(s1))
	fmt.Println(string(s0))
}
```', '["string\nsome string\nstrong", "some string\nsome string\nstrong", "strong\nsome strong\nsome string", "strong\nstring\nsome string"]', 2, 's2 - это срез байтов из s1, начиная с 5-го индекса. Затем в s2 изменяется 3-й индекс на символ "o". При выводе string(s2) мы видим измененную строку "strong". После этого выводится string(s1), которая также отражает изменение в s1. Наконец, выводится string(s0), которая остается неизменной, так как она не была изменена.
[playgroung](https://goplay.space/#AfwK9Dq2CBD)', 'middle'),

('Что такое реляционные базы данных?
```
  1. База данных, в которой информация хранится в виде двумерных таблиц, связанных между собой
  2. База данных, в которой одна ни с чем не связанная таблица
  3. Любая база данных - реляционная
  4. Совокупность данных, не связанных между собой
```', '["1", "2", "3", "4"]', 0, 'Реляционные базы данных — это система хранения и организации информации, имеющей установленные отношения, что обеспечивает возможность для быстро доступа. В этом случае данные упорядочиваются с использованием табличных форм, содержащих сведения об их сущности. Строки и столбцы в таких таблицах представляют заранее установленные категории данных.', 'sql'),
('Какой оператор используется для проверки существования строки в подзапросе?', '["EXIST", "IN", "ANY", "ALL"]', 0, 'Оператор EXISTS проверяет наличие одной или более строк в подзапросе и возвращает TRUE, если подзапрос возвращает одну или несколько строк.', 'sql'),
('Какой тип индекса в PostgreSQL лучше всего подходит для полнотекстового поиска?', '["BTREE", "HASH", "GIN", "BRIN"]', 2, 'Индексы типа GIN (Generalized Inverted Index) специально оптимизированы для полнотекстового поиска и позволяют эффективно индексировать текстовые данные.', 'sql'),
('Какой ключевое слово используется для создания внешнего ключа?', '["FOREIGN", "PRIMARY", "REFERENCES", "CHECK"]', 2, 'При создании внешнего ключа используется ключевое слово REFERENCES, которое указывает на таблицу и столбец, на которые ссылается внешний ключ.', 'sql'),
('Какой тип данных в PostgreSQL используется для хранения больших текстовых блоков?', '["CHAR", "VARCHAR", "STRING", "TEXT"]', 3, 'Тип данных TEXT используется для хранения больших текстовых блоков без ограничения на размер.', 'sql'),
('Что такое выражение GROUP BY и как оно используется?
```
  1. Для сортировки данных в запросе
  2. Для группировки строк по уникальным значениям одного или нескольких столбцов
  3. Для фильтрации данных в запросе
  4. Для объединения результатов двух запросов
```', '["1", "2", "3", "4"]', 1, 'GROUP BY используется для группировки строк по уникальным значениям одного или нескольких столбцов, что позволяет выполнять агрегатные функции, такие как SUM(), AVG(), COUNT(), на каждой группе.', 'sql'),
('Что такое первичный ключ в SQL и почему он важен?
```
  1. Столбец, который может содержать NULL значения
  2. Уникальный идентификатор строки, который не может содержать NULL значения
  3. Столбец, который содержит индекс для быстрого поиска
  4. Столбец, который используется для хранения внешнего ключа
```', '["1", "2", "3", "4"]', 1, 'Первичный ключ (PRIMARY KEY) уникально идентифицирует каждую строку в таблице и не может содержать NULL значения. Он обеспечивает целостность данных и позволяет быстро находить строки.', 'sql'),
('Что такое внешний ключ и как он используется для установления связей между таблицами?
```
  1. Ключ, который обеспечивает уникальность строк в таблице
  2. Ключ, который используется для сортировки данных
  3. Ключ, который содержит индекс для быстрого поиска
  4. Ключ, который ссылается на первичный ключ другой таблицы для установления связей
```', '["1", "2", "3", "4"]', 3, 'Внешний ключ (FOREIGN KEY) используется для установления ссылочной целостности между таблицами, ссылаясь на первичный ключ другой таблицы.', 'sql'),

('В чем разница между базой данных и схемой?
```
  1. Схема – это набор таблиц и других объектов в базе данных
  2. База данных содержит данные, а схема содержит только индексы
  3. База данных – это набор схем, а схема – это набор данных
  4. Схема – это физическое расположение базы данных
```', '["1", "2", "3", "4"]', 0, 'Схема в PostgreSQL – это логическое разделение базы данных, которое содержит таблицы, индексы, функции и другие объекты. База данных может содержать несколько схем.', 'sql'),
('Что такое self-join и когда используется?', '["Соединение таблицы с другой таблицей", "Соединение двух таблиц по первичному ключу", "Соединение двух таблиц по внешнему ключу", "Соединение таблицы с самой собой"]', 3, 'Self-join – это соединение таблицы с самой собой. Оно используется, когда необходимо связать строки одной таблицы друг с другом.', 'sql'),
('В чем разница между внутренним и внешним соединением?
```
  1. Внутреннее соединение возвращает все строки, внешнее – только совпадающие
  2. Внутреннее соединение сортирует данные, внешнее – группирует данные
  3. Внутреннее соединение возвращает только совпадающие строки, внешнее – все строки из одной таблицы и совпадающие строки из другой
  4. Внутреннее соединение объединяет результаты запросов, внешнее – фильтрует данные
```', '["1", "2", "3", "4"]', 2, 'Внутреннее соединение (INNER JOIN) возвращает только строки, которые совпадают в обеих таблицах. Внешнее соединение (OUTER JOIN) возвращает все строки из одной таблицы и совпадающие строки из другой, добавляя NULL для отсутствующих значений.', 'sql'),
('В чем разница между коррелированным и некоррелированным подзапросом?
```
  1. Коррелированный подзапрос выполняется независимо от внешнего запроса, некоррелированный – зависит от него
  2. Коррелированный подзапрос используется для агрегации, некоррелированный – для фильтрации
  3. Коррелированный подзапрос использует индексы, некоррелированный – нет
  4. Коррелированный подзапрос выполняется для каждой строки внешнего запроса, некоррелированный – только один раз
```', '["1", "2", "3", "4"]', 3, 'Коррелированный подзапрос выполняется для каждой строки внешнего запроса, в то время как некоррелированный подзапрос выполняется только один раз и не зависит от внешнего запроса.', 'sql'),
('Что такое обобщенное табличное выражение (CTE) и как оно используется?
```
  1. Это временная таблица, создаваемая на время выполнения запроса
  2. Это подзапрос, который определяется в начале основного запроса и может использоваться многократно
  3. Это постоянная таблица, создаваемая для оптимизации запросов
  4. Это специальный тип индекса для ускорения запросов
```', '["1", "2", "3", "4"]', 1, 'Обобщенное табличное выражение (CTE) – это временное результирующее множество, которое определяется в начале основного запроса с помощью WITH и может многократно использоваться в основном запросе.', 'sql'),
('В чем разница между операторами DELETE и TRUNCATE?
```
  1. DELETE удаляет строки по условию, TRUNCATE – все строки без условия
  2. DELETE удаляет все строки из таблицы, TRUNCATE – только одну
  3. DELETE удаляет строки с возможностью отката, TRUNCATE – без возможности отката
  4. DELETE создает временную таблицу, TRUNCATE – постоянную

```', '["1", "2", "3", "4"]', 0, 'DELETE удаляет строки из таблицы на основе указанного условия, в то время как TRUNCATE мгновенно удаляет все строки из таблицы без возможности указания условия.', 'sql'),
('Что такое временная таблица и как она используется?
```
  1. Таблица, которая создается и удаляется автоматически после завершения сессии
  2. Таблица, которая сохраняет данные навсегда
  3. Таблица, которая используется для хранения данных из внешних источников
  4. Таблица, которая используется для создания индексов
```', '["1", "2", "3", "4"]', 0, 'Временная таблица создается с помощью CREATE TEMPORARY TABLE и существует только в рамках текущей сессии. После завершения сессии она удаляется автоматически.', 'sql'),
('В чем разница между предложениями HAVING и WHERE?
```
  1. WHERE используется для фильтрации групп, HAVING – для фильтрации строк
  2. HAVING используется для фильтрации строк, WHERE – для фильтрации групп
  3. HAVING используется для сортировки данных, WHERE – для группировки данных
  4. WHERE используется для фильтрации строк, HAVING – для фильтрации групп
```', '["1", "2", "3", "4"]', 3, 'WHERE используется для фильтрации строк до агрегации данных, в то время как HAVING используется для фильтрации сгруппированных данных после применения агрегатных функций.', 'sql'),
('Что такое оконная функция и как она используется??
```
1. Функция, которая сортирует строки в таблице
2. Функция, которая создает временные таблицы
3. Функция, которая используется для управления транзакциями
4. Функция, которая выполняет агрегатные операции на наборе строк, связанных с текущей строкой
```', '["1", "2", "3", "4"]', 3, 'Оконные функции выполняют агрегатные операции (например, SUM(), AVG()) на наборе строк, связанных с текущей строкой, без группировки данных.', 'sql'),

('В чем разница между транзакцией и batch?
```
  1. Транзакция – это группа SQL-запросов, выполняемая как единое целое, batch – отдельные SQL-запросы, выполняемые последовательно
  2. Транзакция выполняется быстрее, чем batch
  3. Batch используется для агрегации данных, транзакция – для их сортировки
  4. Batch используется только для чтения данных, транзакция – для их изменения
```', '["1", "2", "3", "4"]', 0, 'Транзакция – это группа SQL-запросов, которые выполняются как единое целое, и все изменения фиксируются или откатываются вместе. Batch – это набор отдельных SQL-запросов, выполняемых последовательно.', 'sql'),

('В чем разница между скалярной и табличной функцией?
```
  1. Скалярная функция возвращает множество строк, табличная – одно значение
  2. Скалярная функция используется для агрегации данных, табличная – для фильтрации
  3. Скалярная функция возвращает одно значение, табличная – множество строк
  4. Скалярная функция выполняется быстрее, чем табличная
```', '["1", "2", "3", "4"]', 2, 'Скалярная функция возвращает одно значение на основе входных данных, в то время как табличная функция возвращает множество строк, как подзапрос.', 'sql'),
('Что такое нормализация и почему она важна?
```
  1. Процесс удаления дубликатов данных для повышения производительности
  2. Процесс разделения таблиц для минимизации избыточности данных и обеспечения целостности данных
  3. Процесс объединения таблиц для упрощения структуры данных
  4. Процесс создания индексов для ускорения запросов
```', '["1", "2", "3", "4"]', 1, 'Нормализация – это процесс организации данных в базе данных путем разделения таблиц для минимизации избыточности и обеспечения целостности данных.', 'sql'),
('Что такое подзапрос SQL и каково его назначение?
```
  1. Запрос, который выполняется после основного запроса
  2. Запрос, который возвращает данные для использования в основном запросе
  3. Запрос, который объединяет результаты двух запросов
  4. Запрос, который сортирует данные
```', '["1", "2", "3", "4"]', 1, 'Подзапрос – это запрос, который выполняется внутри другого запроса и возвращает данные для использования в основном запросе.', 'sql'),
('Что такое индекс в SQL и как он повышает производительность?
```
  1. Структура данных, которая ускоряет выполнение запросов за счет сортировки строк в таблице
  2. Структура данных, которая замедляет выполнение запросов за счет увеличения размера таблицы
  3. Структура данных, которая используется только для временных таблиц
  4. Структура данных, которая выполняет агрегатные функции
```', '["1", "2", "3", "4"]', 0, 'Индекс – это структура данных, которая улучшает производительность запросов за счет ускорения поиска строк в таблице.', 'sql'),
('Что такое оптимизатор SQL-запросов и как он работает?
```
  1. Программа, которая выполняет запросы в базе данных
  2. Компонент СУБД, который определяет наиболее эффективный способ выполнения запроса
  3. Утилита, которая создает индексы для базы данных
  4. Процесс, который объединяет результаты запросов
```', '["1", "2", "3", "4"]', 1, 'Оптимизатор SQL-запросов – это компонент СУБД, который анализирует запрос и определяет наиболее эффективный план его выполнения.', 'sql'),
('Что такое хранимая процедура и каковы её преимущества?
```
  1. SQL-запрос, который выполняется один раз
  2. Процесс, который создает индексы для базы данных
  3. SQL-запрос, который сохраняется и может многократно выполняться
  4. Утилита для управления базой данных
```', '["1", "2", "3", "4"]', 2, 'Хранимая процедура – это заранее компилированный набор SQL-запросов, который хранится в базе данных и может многократно выполняться. Преимущества включают повторное использование, улучшенную производительность и безопасность.', 'sql'),
('Что такое транзакции и зачем они нужны?
```
  1. Набор SQL-запросов, который выполняется параллельно
  2. Набор SQL-запросов, который выполняется как единое целое, с возможностью отката изменений
  3. Утилита для создания индексов
  4. Процесс, который объединяет результаты запросов
```', '["1", "2", "3", "4"]', 1, 'Транзакция – это группа SQL-запросов, которая выполняется как единое целое. Если одна из операций не удается, все изменения могут быть откатаны, что обеспечивает целостность данных.', 'sql'),
('Что такое денормализация и когда её целесообразно использовать?
```
  1. Процесс объединения таблиц для уменьшения избыточности данных
  2. Процесс удаления дубликатов данных
  3. Процесс создания индексов для ускорения запросов
  4. Процесс добавления избыточности данных для улучшения производительности чтения
```', '["1", "2", "3", "4"]', 3, 'Денормализация – это процесс преднамеренного добавления избыточности данных в базу данных для улучшения производительности чтения, часто в ущерб производительности записи.', 'sql'),
('Что такое кластерный индекс и чем он отличается от некластерного?
```
  1. Кластерный индекс сортирует строки в таблице, некластерный – нет
  2. Кластерный индекс используется для временных таблиц, некластерный – для постоянных
  3. Кластерный индекс используется для агрегации данных, некластерный – для фильтрации
  4. Кластерный индекс – это группа индексов, некластерный – один индекс
```', '["1", "2", "3", "4"]', 0, 'Кластерный индекс сортирует физическое расположение строк в таблице, в то время как некластерный индекс создает отдельную структуру данных, указывающую на физическое расположение строк.', 'sql'),
('Что такое триггер и как он используется?
```
  1. SQL-запрос, который выполняется по расписанию
  2. Специальная процедура, которая выполняется автоматически при определенных событиях в таблице
  3. Утилита для управления базой данных
  4. Процесс, который создает индексы для базы данных
```', '["1", "2", "3", "4"]', 1, 'Триггер – это специальная процедура, которая автоматически выполняется при определенных событиях, таких как вставка, обновление или удаление строк в таблице.', 'sql'),
('Что такое ограничение SQL и какие распространенные типы вы знаете?
```
  1. Утилита для управления базой данных
  2. Правило, которое ограничивает тип данных, которые можно хранить в столбце
  3. Правило, которое ограничивает количество строк в таблице
  4. Индекс, который используется для ускорения запросов
```', '["1", "2", "3", "4"]', 1 , 'Ограничение SQL – это правило, которое ограничивает тип данных, которые можно хранить в столбце. Распространенные типы ограничений включают PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL и CHECK.', 'sql'),
('Что такое оператор UNION и для чего он используется?
```
  1. Для объединения строк из двух или более таблиц в одно результирующее множество
  2. Для фильтрации строк в таблице
  3. Для сортировки строк в таблице
  4. Для удаления строк из таблицы
```', '["1", "2", "3", "4"]', 0, 'Оператор UNION используется для объединения строк из двух или более таблиц в одно результирующее множество, исключая дубликаты.', 'sql'),
('Что такое оператор CASE и как он используется?
```
  1. Для объединения строк из нескольких таблиц
  2. Для выполнения условий и возврата значений на основе этих условий
  3. Для создания индексов
  4. Для создания временных таблиц
```', '["1", "2", "3", "4"]', 1, 'Оператор CASE используется для выполнения условий и возврата значений на основе этих условий, аналогично конструкции IF-THEN-ELSE в программировании.', 'sql'),
('Что такое ORDER BY и как оно используется?
```
  1. Для сортировки строк в таблице по одному или нескольким столбцам
  2. Для группировки строк в таблице по одному или нескольким столбцам
  3. Для фильтрации строк в таблице
  4. Для объединения строк из нескольких таблиц
```', '["1", "2", "3", "4"]', 0, 'ORDER BY используется для сортировки строк в результирующем множестве по одному или нескольким столбцам в порядке возрастания или убывания.', 'sql'),
('Сложность поиска b-tree?
```
  1. O(n)
  2. O(log n)
  3. O(n^2)
  4. O(1)
```', '["1", "2", "3", "4"]', 1, 'Поиск в B-дереве эффективен из-за его структуры, которая обеспечивает логарифмическую сложность поиска, что делает его быстрым даже для больших наборов данных.', 'sql'),
('Составные индексы - когда они полезны?
```
  1. Полезны, когда запросы часто фильтруют данные по нескольким столбцам
  2. Полезны, когда запросы используют только один столбец
  3. Бесполезны, когда таблица имеет мало строк
  4. Бесполезны, когда таблица часто обновляется
```', '["1", "2", "3", "4"]', 0, 'Составные индексы полезны, когда запросы часто фильтруют данные по нескольким столбцам, так как они могут значительно улучшить производительность таких запросов.', 'sql'),
('Для чего нужны индексы?
```
  1. Для увеличения количества строк в таблице
  2. Для улучшения производительности запросов, но они могут замедлить операции вставки и обновления
  3. Для фильтрации данных
  4. Для создания временных таблиц
```', '["1", "2", "3", "4"]', 1, 'Индексы используются для улучшения производительности запросов, ускоряя поиск строк. Однако они могут замедлить операции вставки и обновления, так как индексы нужно обновлять при изменении данных.', 'sql');