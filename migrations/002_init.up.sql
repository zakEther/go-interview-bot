CREATE TABLE sessions (
  session_id char(128) PRIMARY KEY,
  user_id BIGINT,
  questions JSONB,
  user_answers INT[],
  expired_at TIMESTAMP
);

CREATE TABLE questions (
  question_id SERIAL PRIMARY KEY,
  question_text TEXT NOT NULL,
  question_options JSONB NOT NULL,
  answer INT NOT NULL,
  explanation TEXT,
  grade TEXT NOT NULL
);

INSERT INTO questions (question_text, question_options, answer, explanation, grade)
VALUES
('Что такое горутина (goroutine) в Go?', '["Класс объектов", "Поток выполнения", "Интерфейс", "Группа функций"]', 1, 'Это легковесные потоки, которые реализуют конкурентное программирование. Они управляются рантаймом, а не операционной системой', 'junior'),
('Каким образом проверить ошибку в Go?', '["if err != nil { }", "err := checkError()", "if error { }", "if err == nil { }"]', 0, 'Нужно сначала вернуть из функции переменную err, а потом проверить ее на nil', 'junior'),
('Что такое defer в Go?', '["Запись данных", "Выполнение после возврата", "Оператор итерации", "Отложенное выполнение"]', 3, 'Ключевое слово defer используется для отложенного выполнения функции/метода до тех пор, пока текущая функция не завершится', 'junior'),
('Каким образом происходит передача параметров в функции в Go?', '["По значению (pass by value)", "По ссылке (pass by reference)", "По указателю", "По имени параметра"]', 0, 'Всякий раз, когда мы передаем аргумент в функцию, функция получает копию первоначального значения', 'junior'),
('Что такое слайс (slice) в Go?', '["Указатель на массив", "Динамический массив", "Класс для работы с файлами", "Массив фиксированного размера"]', 1, 'Это массив неопределённой длины', 'junior'),
('Что такое интерфейс в Go?', '["Набор методов", "Имя типа данных", "Указатель на функцию", "Описание структуры"]', 0, 'Набор методов', 'junior'),
('Каким образом происходит обработка ошибок в Go?', '["Исключения", "Возврат ошибки в функции", "Ловушка для ошибок", "Паника"]', 1, 'Ошибки - значения, возвращаемые функциями', 'junior'),
('Что такое метод в Go?', '["Функция, связанная с определенным типом", "Глобальная функция", "Макрос", "Синтаксическая конструкция"]', 1, 'В Go нет классов, но существуют структуры с методами. Метод — это функция с дополнительным аргументом, который указывается в скобках между func и названием функции', 'junior'),
('Go - императивный или декларативный?', '["не знаю", "декларативный", "императивный и декларативный", "императивный"]', 3, 'Императивное программирование — это описание того, как ты делаешь что-то (т.е. конкретно описываем необходимые действия для достижения определенного результата), а декларативное — то, что ты делаешь', 'junior'),
('Что представляют из себя строки в go?', '["не знаю", "массив байт", "тип данных, предназначенный для работы с текстом", "любые текстовые данные"]', 1, 'это последовательность байт', 'junior'),
('Что получится, если разделить int на 0, float на 0?', '["паника в обоих случаях", "невозможно в обоих случаях", "ошибка/бесконечность", "ноль/ноль"]', 2, 'Деление int на 0 в go невозможно и вызовет ошибку компилятора, а деление float на 0 дает в своем результате бесконечность.', 'junior'),
('Как создать новую горутину в Go?', '["go func()", "new goroutine", "goroutine func()", "start go func"]', 0, 'Для создания новой горутины в Go используется ключевое слово go перед вызовом функции.', 'junior'),
('Как проверить длину слайса в Go?', '["size(slice)", "length(slice)", "len(slice)", "count(slice)"]', 2, 'Для проверки длины слайса в Go используется функция len().', 'junior'),
('Как объявить структуру в Go?', '["struct Struct {}", "type Struct struct {}", "struct {} Struct", "define Struct {}"]', 1, 'В Go структуры объявляются с использованием ключевых слов type и struct.', 'junior'),
('Как создать канал в Go?', '["create(chan int)", "make(chan int)", "new(chan int)", "chan int{}"]', 1, 'Для создания канала в Go используется функция make().', 'junior'),
('Что делает оператор select в Go?', '["Выбирает случайный канал", "Параллельно выполняет функции", "Синхронизирует выполнение горутин", "Выполняет операции с несколькими каналами"]', 3, 'select позволяет go-процедуре находиться в ожидании нескольких операций передачи данных. select блокируется до тех пор, пока один из его блоков case не будет готов к запуску, а затем выполняет этот блок. Если сразу несколько блоков могут быть запущены, то выбирается рандомный', 'junior'),
('Как инициализировать слайс с длиной 5 в Go?', '["make([]int, 5)", "create([]int, 5)", "new([]int, 5)", "[]int{5}"]', 0, 'Для инициализации слайса с длиной 5 в Go используется функция make([]int, 5).', 'junior'),
('Что возвращает функция recover() в Go?', '["Ошибку", "Паническое значение", "Значение nil", "Статус выполнения"]', 1, 'Функция recover() в Go возвращает паническое значение, если она вызывается в отложенной функции после panic().', 'junior'),
('Как в Go избежать состояния гонки?', '["Использовать мьютексы", "Использовать каналы", "Использовать атомарные операции", "Все вышеперечисленное"]', 3, 'В Go можно избежать состояния гонки, используя мьютексы, каналы и атомарные операции.', 'junior'),
('Что делает функция runtime.Gosched() в Go?', '["Завершает текущую горутину", "Усыпляет текущую горутину", "Передает управление другой горутине", "Останавливает все горутины"]', 2, 'Функция runtime.Gosched() передает управление другой горутине, позволяя планировщику выполнить другие задачи.', 'junior'),
('Как в Go реализуется наследование?', '["Использование интерфейсов", "Встраивание структур", "Наследование классов", "Все вышеперечисленное"]', 1, 'В Go наследование реализуется через встраивание структур.', 'junior'),
('Какую роль играет интерфейс в Go?', '["Определяет методы, которые должен реализовать тип", "Объявляет поля структуры", "Определяет пакет", "Объявляет переменную"]', 0, 'Интерфейс в Go определяет методы, которые должен реализовать тип.', 'junior'),
('Как в Go реализовать чистую архитектуру?', '["Разделение логики на слои", "Использование интерфейсов для взаимодействия между слоями", "Использование зависимостей, инъекций и тестов", "Все вышеперечисленное"]', 3, 'В Go чистая архитектура реализуется через разделение логики на слои, использование интерфейсов и зависимостей, инъекций и тестов.', 'junior'),
('Как вызвать метод, привязанный к структуре, в Go?', '["instance.method()", "method(instance)", "instance->method()", "instance:method()"]', 0, 'Метод, привязанный к структуре, вызывается с использованием синтаксиса instance.method().', 'junior'),
('Что такое пустой интерфейс interface{} в Go?', '["Интерфейс без методов", "Интерфейс с одним методом", "Интерфейс для работы с каналами", "Интерфейс для работы с файлами"]', 0, 'Пустой интерфейс interface{} не содержит методов и может быть использован для хранения значения любого типа.', 'junior'),
('Как объявить метод с указателем на структуру в качестве получателя в Go?', '["func (s StructType) MethodName()", "func (s *StructType) MethodName()", "func MethodName(s StructType)", "func MethodName(s *StructType)"]', 1, 'Метод с указателем на структуру в качестве получателя объявляется с использованием синтаксиса func (s *StructType) MethodName().', 'junior'),
('Как объявить анонимную функцию в Go?', '["func() {}", "() => {}", "function() {}", "func {}"]', 0, 'Анонимная функция объявляется с использованием синтаксиса func() {}.', 'junior'),
('Как определить метод, который может принимать параметры любого типа в Go?', '["func MethodName[T any](param T)", "func MethodName(param interface{})", "func MethodName(param ...interface{})", "func MethodName(param T)"]', 2, 'Метод, который может принимать параметры любого типа, определяется с использованием синтаксиса func MethodName(param ...interface{}).', 'junior'),
('Как в Go реализовать обобщенные типы?', '["Использовать интерфейсы", "Использовать пустые интерфейсы", "Использовать параметры типов", "Go не поддерживает обобщенные типы"]', 3, 'На данный момент Go не поддерживает обобщенные типы напрямую.', 'junior'),
('Как определить deadlock в Go программе?', '["Программа завершает работу с ошибкой", "Все горутины заблокированы", "Программа зависает", "Все вышеперечисленное"]', 3, 'Deadlock в Go программе проявляется, когда все горутины заблокированы и программа зависает или завершает работу с ошибкой.', 'junior'),
('Какое значение принимает неинициализированная переменная int в Go?', '["nil", "1", "0", "-1"]', 2, 'Неинициализированная переменная int принимает значение 0 в Go.', 'junior'),
('Какой метод используется для преобразования строки в число с плавающей точкой?', '["strconv.Atoi()", "strconv.ParseFloat()", "strconv.ParseInt()", "strconv.FormatFloat()"]', 1, 'Метод strconv.ParseFloat() используется для преобразования строки в число с плавающей точкой.', 'junior'),
('Что делает ключевое слово fallthrough в конструкции switch?', '["Завершает выполнение switch", "Продолжает выполнение следующего case", "Вызывает панику", "Пропускает текущий case"]', 1, 'Ключевое слово fallthrough продолжает выполнение следующего case в конструкции switch.', 'junior'),
('Как объявить метод, который принимает переменное количество аргументов одного типа?', '["func MethodName(args ...Type)", "func MethodName(args []Type)", "func MethodName(args ...interface{})", "func MethodName(args ...T)"]', 0, 'Метод, который принимает переменное количество аргументов одного типа, объявляется с использованием синтаксиса func MethodName(args ...Type).', 'junior'),
('Какое значение можно использовать в конструкции select для выполнения по умолчанию?', '["default:", "else:", "case nil:", "switch:"]', 0, 'Значение default: используется в конструкции select для выполнения по умолчанию, если ни один из case не готов к выполнению.', 'junior'),
('Как объявить метод, который будет доступен только внутри пакета?', '["func methodName() {}", "func MethodName() {}", "private func methodName() {}", "internal func methodName() {}"]', 0, 'Метод, который начинается с маленькой буквы, будет доступен только внутри пакета.', 'junior'),
('Что делает функция copy() в Go?', '["Копирует данные из строки в строку", "Копирует данные из карты в карту", "Копирует данные из структуры в структуру", "Копирует данные из одного среза в другой"]', 3, 'Функция copy() копирует данные из одного среза в другой.', 'junior'),
('Что произойдет, если два разных пакета импортируют друг друга?', '["Будет ошибка компиляции", "Программа зависнет", "Будет ошибка времени выполнения", "Программа выполнится без ошибок"]', 0, 'Если два разных пакета импортируют друг друга, будет ошибка компиляции из-за циклической зависимости.', 'junior'),
('Как объявить канал, который может только отправлять данные?', '["chan int", "<-chan int", "chan<- int", "chan<- int, <-chan int"]', 2, 'Канал, который может только отправлять данные, объявляется как chan<- int.', 'junior'),
('Какой метод используется для настройки параллелизма выполнения тестов?', '["t.concurrent()", "t.RunParallel()", "t.Run()", "t.Concurrent()"]', 2, 'Метод t.Parallel() используется для настройки параллелизма выполнения тестов.', 'junior'),
('Какой метод из пакета context используется для создания дочернего контекста с тайм-аутом?', '["WithCancel", "WithDeadline", "WithTimeout", "WithValue"]', 2, 'Метод context.WithTimeout используется для создания дочернего контекста с тайм-аутом.', 'junior'),
('Чем отличается интерфейс от структуры в Go?', '["Интерфейс не содержит методов", "Структура используется только для хранения данных", "Интерфейс определяет только поведение, а структура - данные и поведение", "Структура определяет только поведение"]', 2, 'Интерфейс в Go определяет только поведение, а структура может содержать и данные, и поведение.', 'junior'),
('Что такое пакетный рантайм (package runtime) в Go?', '["Встроенные функции для работы с пакетами", "Часть стандартной библиотеки, обеспечивающая основные функции исполнения программы", "Интерфейсы для работы с горутинами", "Расширения стандартной библиотеки"]', 1, 'Пакетный рантайм в Go - это часть стандартной библиотеки, которая обеспечивает основные функции исполнения программы, включая управление памятью и горутинами.', 'junior'),
('Из чего состоит файл go.mod?', '["Список всех используемых пакетов", "Информация о версии Go", "Метаданные проекта и его зависимости", "Исполняемый файл проекта"]', 2, 'Файл go.mod состоит из метаданных проекта и его зависимостей, включая список используемых пакетов и их версии.', 'junior'),
('Для чего нужен replace в go.mod?', '["Для временного отключения зависимостей", "Для замены стандартных пакетов на пользовательские реализации", "Для перехода на другую версию Go", "Для обновления всех зависимостей"]', 1, 'Ключевое слово replace в go.mod используется для замены стандартных пакетов на пользовательские реализации в процессе разработки или тестирования.', 'junior'),
('Что означает indirect в go.mod?', '["Зависимость не явно задана в проекте", "Зависимость косвенно используется в проекте", "Зависимость не должна обновляться автоматически", "Зависимость используется только для разработки"]', 1, 'Когда зависимость помечена как indirect в go.mod, это означает, что она косвенно используется в проекте через другие зависимости.', 'junior'),
('Что включает в себя структура слайса?', '["len, cap", "len и cap", "Ссылку на базовый массив, len и cap", "Слайс это не структура"]', 2, 'Слайс - структура go, которая содержит в себе ссылку на базовый массив, длину (len) и ёмкость (cap).', 'junior'),
('Что такое Big O-нотация?', '["Оценка объема памяти, используемого алгоритмом", "Оценка времени работы алгоритма в среднем случае", "Оценка времени работы алгоритма в худшем случае", "Все вышеперечисленное"]', 2, 'Big O-нотация используется для оценки временной сложности алгоритма в худшем случае.', 'junior'),
('Может ли стек горутины быть бесконечным?', '["Да, может быть", "Нет, размер стека ограничен доступной физической памятью", "Да, если горутина использует мало памяти", "Нет, стек горутины имеет фиксированный размер"]', 1, 'Стек горутины зависит от архитектуры и составляет 1ГБ для 64-разрядных систем и 250МБ для 32-разрядных систем.', 'junior'),
('Чему равны zero-value для слайса?', '["error,", "0, 0", "false", "nil, nil"]', 1, 'Zero-value для слайса - nil, а его длина и ёмкость (len, cap) равны нулю, т.к. "под ним" нет инициализированного масива', 'junior'),
('Как проверить слайс var a []int на пустоту?', '["fmt.Println(a == nil)", "fmt.Println(!a)", "Стандартная библиотека не даёт проверки слайса на пустоту","fmt.Println(len(a) == 0)"]', 3, 'Самый надежный способ проверить слайс на пустоту - это проверить его длину на ноль.', 'junior'),

('Каким образом проверить ошибку в Go?', '["if err != nil { }", "err := checkError()", "if error { }", "if err == nil { }"]', 0, 'Нужно сначала вернуть из функции переменную err, а потом проверить ее на nil', 'junior'),
('Что такое goroutine leak?', '["Потеря горутин", "Завершение горутин", "Утечка горутин", "Ошибка в горутине"]', 2, 'Goroutine leak — это утечка горутин, которая продолжает работать, когда она уже не нужна.', 'middle'),
('Какой из подходов лучше всего использовать для параллельной обработки данных в Go?', '["Структуры и интерфейсы", "Мьютексы и условные переменные", "Стандартные функции и методы", "Горутины и каналы"]', 3, 'В Go для параллельной обработки данных лучше всего использовать горутины и каналы.', 'middle'),
('Что такое race condition и как его избежать в Go?', '["Конкуренция за ресурсы между горутинами", "Проблемы с памятью", "Неправильное использование функций", "Ошибки при работе с интерфейсами"]', 0, 'Race condition — это конкуренция за ресурсы между горутинами. Его можно избежать, используя мьютексы, каналы и атомарные операции.', 'middle'),
('Как использовать пакет sync в Go для синхронизации горутин?', '["sync.Mutex", "sync.WaitGroup", "sync.Cond", "Все вышеперечисленное"]', 3, 'Пакет sync в Go предоставляет такие примитивы синхронизации, как sync.Mutex, sync.WaitGroup и sync.Cond.', 'middle'),
('Как реализовать шаблон проектирования "Фабрика" в Go?', '["Использовать функции-конструкторы", "Использовать методы структур", "Использовать интерфейсы", "Использовать пакеты"]', 0, 'В Go шаблон проектирования "Фабрика" можно реализовать с помощью функций-конструкторов.', 'middle'),
('Как в Go работает garbage collection?', '["Оптимизирует работу программы", "Управляет выделением и освобождением памяти вручную", "Освобождает память, занимаемую ненужными объектами", "Автоматически исправляет ошибки"]', 2, 'Garbage collection в Go автоматически освобождает память, занимаемую ненужными объектами.', 'middle'),
('Что такое pattern matching (сопоставление значения с шаблоном) в Go?', '["Сопоставление с шаблоном", "Ответы a, c", "Использование регулярных выражений", "Go не поддерживает pattern matching"]', 3, 'Go не поддерживает pattern matching, который присутствует в других языках, таких как Haskell или Erlang.', 'middle'),
('Какой из методов соответствует интерфейсу io.Reader в Go?', '["Write(p []byte) (n int, err error)", "Read(p []byte) (n int, err error)", "Close() error", "Open(name string) (file *File, err error)"]', 1, 'Метод Read(p []byte) (n int, err error) соответствует интерфейсу io.Reader, который позволяет считывать данные из источника в буфер p.', 'middle'),
('Что произойдет, если вызвать метод на nil указателе в Go?', '["Программа завершится с паникой", "Метод будет вызван без ошибок", "Вернется nil", "Будет вызван метод nil объекта"]', 0, 'Если вызвать метод на nil указателе, программа завершится с паникой, если метод не обрабатывает nil указатели явно.', 'middle'),
('Какой метод из пакета sync.WaitGroup уменьшает счетчик горутин на единицу?', '["Done()", "Add()", "Wait()", "Subtract()"]', 0, 'Метод Done() уменьшает счетчик горутин на единицу в пакете sync.WaitGroup.', 'middle'),
('Что произойдет, если закрыть канал, и потом попытаться отправить в него значение?', '["Будет отправлено значение", "Программа завершится с паникой", "Ничего не произойдет", "Будет создан новый канал"]', 1, 'Если закрыть канал и потом попытаться отправить в него значение, программа завершится с паникой.', 'middle'),
('Что произойдет, если не вызвать метод Done() на WaitGroup в Go?', '["Программа завершится с ошибкой", "Программа будет ждать бесконечно", "Ничего не произойдет", "Будет вызвана паника"]', 1, 'Если не вызвать метод Done() на WaitGroup, программа будет ждать бесконечно, так как WaitGroup никогда не достигнет нуля.', 'middle'),
('Что произойдет, если вызвать panic внутри defer функции?', '["Ничего не произойдет", "Программа продолжит выполнение", "Другая defer функция будет вызвана", "Программа завершится с паникой"]', 3, 'Если вызвать panic внутри defer функции, программа завершится с паникой после выполнения всех остальных отложенных функций.', 'middle'),
('Как определить метод, который принимает и возвращает каналы?', '["func MethodName(chan int) chan int", "func MethodName(chan<- int) <-chan int", "func MethodName(chan int) (chan int)", "Все вышеперечисленное"]', 3, 'Все вышеперечисленные способы определяют метод, который принимает и возвращает каналы.', 'middle'),
('Что произойдет, если вызвать метод на nil интерфейсе в Go?', '["Программа завершится с паникой", "Метод будет вызван без ошибок", "Вернется nil", "Будет вызван метод nil объекта"]', 0, 'Если вызвать метод на nil интерфейсе, программа завершится с паникой, если метод не обрабатывает nil явно.', 'middle'),
('Какой тип блокировки обеспечивает одновременное чтение, но эксклюзивное написание?', '["Mutex", "RWMutex", "Once", "WaitGroup"]', 1, 'RWMutex (Read-Write Mutex) обеспечивает одновременное чтение, но эксклюзивное написание.', 'middle'),
('Что произойдет, если не закрыть канал, который больше не используется?', '["Программа завершится с ошибкой", "Произойдет утечка памяти", "Горутины, ожидающие на этом канале, заблокируются", "Ничего не произойдет"]', 2, 'Если не закрыть канал, горутины, ожидающие на этом канале, заблокируются.', 'middle'),
('Что произойдет, если вызывать метод Lock() на уже заблокированном мьютексе?', '["Программа завершится с ошибкой", "Произойдет дедлок", "Горутина продолжит выполнение", "Мьютекс автоматически разблокируется"]', 1, 'Если вызвать метод Lock() на уже заблокированном мьютексе, произойдет дедлок, т.к. горутина будет ждать освобождения мьютекса.', 'middle'),
('Какой тип блокировки обеспечивает однократное выполнение определенного кода?', '["Mutex", "RWMutex", "Once", "WaitGroup"]', 3, 'Once обеспечивает однократное выполнение определенного кода.', 'middle'),
('Как избежать утечек памяти при использовании таймеров в Go?', '["Использовать defer для остановки таймера", "Использовать таймеры с канала", "Обнулять таймер", "Использовать context для отмены"]', 0, 'Использование defer для остановки таймера помогает избежать утечек памяти.', 'middle'),
('Что произойдет, если вызвать метод RLock() на RWMutex в Go, когда другой горутин вызвал Lock()?', '["Произойдет дедлок", "Метод RLock() будет блокироваться до освобождения Lock()", "Будет вызвана паника", "Горутина продолжит выполнение"]', 1, 'Метод RLock() будет блокироваться до тех пор, пока Lock() не будет освобожден.', 'middle'),
('Какой метод используется для завершения работы горутины при закрытии программы?', '["runtime.Goexit()", "runtime.Gosched()", "runtime.GC()", "runtime.NumGoroutine()"]', 0, 'Метод runtime.Goexit() используется для завершения работы текущей горутины.', 'middle'),
('Какой метод из пакета sync используется для безопасного доступа к целочисленным значениям из нескольких горутин?', '["sync.RWMutex.RLock()", "sync.Mutex.Lock()", "sync.WaitGroup.Wait()", "sync/atomic.AddInt32()"]', 3, 'Метод sync/atomic.AddInt32() используется для безопасного доступа и изменения целочисленных значений из нескольких горутин.', 'middle'),
('Какой алгоритм сортировки имеет наилучшую временную сложность в среднем случае среди сравнительных алгоритмов?', '["Пузырьковая сортировка (Bubble Sort)", "Сортировка слиянием (Merge Sort)", "Быстрая сортировка (Quick Sort)", "Вставочная сортировка (Insertion Sort)"]', 2, 'Быстрая сортировка (Quick Sort) имеет наилучшую временную сложность O(n log n) в среднем случае среди сравнительных алгоритмов сортировки.', 'middle'),
('Что такое gRPC в контексте сетевого взаимодействия в Go?', '["Протокол для передачи SOAP-сообщений", "Формат передачи данных через RESTful API", "Протокол для удаленного вызова процедур (RPC) с использованием HTTP/2", "Фреймворк для разработки веб-приложений"]', 3, 'gRPC - это протокол для удаленного вызова процедур (RPC) с использованием HTTP/2, предназначенный для эффективного взаимодействия между различными сервисами.', 'middle'),
('Какие преимущества предоставляет gRPC по сравнению с RESTful API?', '["Более высокая производительность и эффективность благодаря использованию HTTP/2 и сериализации Protocol Buffers", "Простота использования и понимания", "Легкость в развертывании", "Все вышеперечисленное"]', 0, 'gRPC предлагает более высокую производительность и эффективность благодаря использованию HTTP/2 и сериализации Protocol Buffers.', 'middle'),
('Какое преимущество предоставляет использование Protocol Buffers в gRPC?', '["Простота в использовании", "Высокая производительность при передаче данных", "Легкость в развертывании", "Возможность работы с JSON-форматом"]', 1, 'Protocol Buffers предоставляют высокую производительность при передаче данных благодаря компактному бинарному формату.', 'middle'),
('Какой тип данных в Go часто используется для представления JSON-структур в RESTful API?', '["Структуры", "Массивы", "Карты", "Целые числа"]', 0, 'В Go для представления JSON-структур в RESTful API часто используются структуры данных.', 'middle'),
('Что выведет код?
```
package main

func main(){
  for counter, i := 0, 0; i < 9; i++ {
    defer func() {
      if counter%2 == 1 {
        print(counter)
      }
      counter++
    }()
  }
}
```', '["Ничего", "1357", "Зависит от версии языка", "Ошибка компиляции"]', 2, 'В версии 1.22 изменилась семантика for, поэтому вывод будет зависеть от версии', 'junior'),
('Что выведет код?
```
package main

import "fmt"

func main(){
  var a uint8 = 10
  var b uint8 = 30
  var c uint8 = a * b
  fmt.Println(c)
}
```', '["300", "44", "Ошибку компиляции", "344"]', 1, 'Максимальное значение uint8 - 255, поэтому результат обернётся вокруг этого максимального значения и будет равен 300-256=44
[playgroung](https://goplay.space/#ZXCOdU5Tql0)', 'junior'),
('Что выведет код?
```
package main

func main() {
	v := 5
	p := &v
	println(*p)

	changePointer(p)
	println(*p)
}

func changePointer(p *int) {
	v := 3
	p = &v
}

```', '["5, 5", "5", "Ошибку компиляции", "panic"]', 0, 'В функции changePointer мы изменяем сам указатель p, но не изменяем значение, на которое он указывает. Когда мы передаем указатель p в функцию changePointer, создается копия указателя p, которая указывает на значение 3. Но, после завершения функции changePointer, эта копия уничтожается, и исходный указатель p в функции main остается указывать на значение 5.
[playgroung](https://goplay.space/#E3C3hi4asTQ)', 'middle'),

('Какое будет значение у переменной x после выполнения программ?
```
package main

func square(x *float64) {
	*x = *x * *x
}

func main() {
	x := 1.5
	square(&x)

	fmt.Println(x)
}

```', '["1.25", "2.25", "2.5", "1"]', 1, 'Это происходит потому, что в функции square мы передаем указатель на переменную x, а не саму переменную. В функции square происходит умножение значения, на которое указывает указатель x, на само это значение. Таким образом, значение переменной x изменяется на результат умножения 1.5 на 1.5, что равно 2.25.
[playgroung](https://goplay.space/#J-R1I5Ih8Jt)', 'middle');